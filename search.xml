<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Learning JavaScript 02</title>
      <link href="2021/01/14/JavaScript-02/"/>
      <url>2021/01/14/JavaScript-02/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Programming Languages </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch 02 —— Autoguard</title>
      <link href="2021/01/13/Pytorch-02/"/>
      <url>2021/01/13/Pytorch-02/</url>
      
        <content type="html"><![CDATA[<h1 id="张量-Tensor"><a href="#张量-Tensor" class="headerlink" title="张量(Tensor)"></a>张量(Tensor)</h1><p><code>torch.Tensor</code>是包的核心类。如果将属性<code>.requires_grad</code>设置为<code>True</code>，则会开始跟踪上面的所有操作。完成计算后，可以调用<code>.backward()</code>并自动计算所有梯度。张量的梯度将累积到<code>.grad</code>属性中</p><p>要阻止张量跟踪历史记录，可以调用<code>.detach()</code>将其从计算历史中分离出来，并防止将来的计算被跟踪</p><p>要防止跟踪历史记录（和使用内存），还可以使用<code>torch.no_grad()</code>包中那个代码块</p><p>还有一个类对于autograd实现非常重要 - Function。</p><p>Tensor和Function互相连接并构建一个非循环图构建一个完整的计算过程。每个张量都有一个<code>.grad_fn</code>属性，该属性引用已创建Tensor的Function（除了用户创建的Tensors - 它们的<code>grad_fn</code>为<code>None</code>）。</p><p>如果要计算导数，可以在Tensor上调用<code>.backward()</code>。如果Tensor是标量（即它包含一个元素数据），则不需要为<code>backward()</code>指定任何参数，但是如果它有更多元素，则需要指定一个梯度参数，该参数是匹配形状的张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个张量并设置 requires_grad = True 以跟踪它的计算</span></span><br><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><p> Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 1.],</span><br><span class="line">        [1., 1.]], requires_grad&#x3D;True)</span><br></pre></td></tr></table></figure><p>在张量上执行操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = x + <span class="number">2</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[3., 3.],</span><br><span class="line">        [3., 3.]], grad_fn&#x3D;&lt;AddBackward0&gt;)</span><br></pre></td></tr></table></figure><p>因为y是通过一个操作创建的，所以它有<code>grad_fn</code>，而x是用户创建的，所以它的<code>grad_fn</code>为<code>None</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(y.grad_fn)</span><br><span class="line">print(x.grad_fn)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Output:</span></span><br><span class="line"><span class="string">&lt;AddBackward0 object at 0x7f854061ec50&gt;</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在y上执行操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">z = y * y * <span class="number">3</span></span><br><span class="line">out = z.mean()</span><br><span class="line"></span><br><span class="line">print(z, out)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Output:</span></span><br><span class="line"><span class="string">tensor([[27., 27.],</span></span><br><span class="line"><span class="string">        [27., 27.]], grad_fn=&lt;MulBackward0&gt;) tensor(27., grad_fn=&lt;MeanBackward0&gt;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><code>.requires\_grad_(...)</code>就地更改现有的Tensor的<code>requires_grad</code>标志。 如果没有给出，输入标志默认为False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">a = ((a * <span class="number">3</span>) / (a - <span class="number">1</span>))</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">a.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">b = (a * a).<span class="built_in">sum</span>()</span><br><span class="line">print(b.grad_fn)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Output:</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&lt;SumBackward0 object at 0x7f8540621090&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h1><p>来执行反向传播,<code>out.backward()</code>，相当于执行<code>out.backward(torch.tensor(1.))</code></p>]]></content>
      
      
      <categories>
          
          <category> Programming Languages </category>
          
          <category> Python </category>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Python </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning JavaScript 01</title>
      <link href="2021/01/10/JavaScript-01/"/>
      <url>2021/01/10/JavaScript-01/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML中的JavaScript"><a href="#HTML中的JavaScript" class="headerlink" title="HTML中的JavaScript"></a>HTML中的JavaScript</h1><h2 id="“script”标签"><a href="#“script”标签" class="headerlink" title="“script”标签"></a>“script”标签</h2><p>JavaScript程序可以在<code>&lt;script&gt;</code>标签的帮助下插入到HTML文档的任何地方，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>script 标签之前...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;Hello, world!&#x27;</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>...script 标签之后<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;script&gt;</code>标签中包裹了JavaScript代码，当浏览器遇到<code>&lt;script&gt;</code></p><h2 id="外部脚本"><a href="#外部脚本" class="headerlink" title="外部脚本"></a>外部脚本</h2><p>如果含有大量JavaScript代码，可以将其放入一个单独的文件中，脚本可以通过<code>src</code>特性（attribute）添加到HTML文件中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/path/to/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里，<code>/path/to/script.js</code>是脚本文件从网站根目录开始绝对路径，也可以提供相对路径或完整的URL地址。</p><p>要附加多个脚本，需要使用多个标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src-</span>&quot;/<span class="attr">js</span>/<span class="attr">script1.js</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src-</span>&quot;/<span class="attr">js</span>/<span class="attr">script2.js</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>如果设置了<code>src</code>特性，<code>script</code>标签内容将被忽略</p></div><h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>当存在换行符（line break）时，在大多数情况下可以省略分号，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">alert(<span class="string">&#x27;World&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此时，JavaScript将换行理解成“隐式”的分号，这被称为<strong>自动分号插入</strong>，但是并不总是这样的，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">3</span> +</span><br><span class="line"><span class="number">1</span></span><br><span class="line">+ <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>会输出<code>6</code>，因为JavaScript没有在这里加入分号。</p><div class="note info simple"><p>即使大部分时候可以省略分号，但最好还是不要省略</p></div><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释以两个正斜杠<code>//</code>开始，剩余部分是注释，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这行注释独占一行</span></span><br><span class="line">alert(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;World&#x27;</span>); <span class="comment">// 这行注释跟随在语句后面</span></span><br></pre></td></tr></table></figure><p>多行注释以<code>/*</code>开始，以<code>*/</code>结束，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 两个消息的例子。</span></span><br><span class="line"><span class="comment">这是一个多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">alert(<span class="string">&#x27;World&#x27;</span>);</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>不支持注释嵌套</p><p>不能再<code>/**/</code>中嵌套一个<code>/**/</code></p></div><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><p>在JavaScript中创建一个变量，我们需要用到<code>let</code>关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br></pre></td></tr></table></figure><p>创建了一个名为“message”的变量。</p><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>JavaScript的变量命名有两个限制：</p><ol><li>变量名必须仅包含字母，数字，符号<code>$</code>和<code>_</code></li><li>首字母必须非数字</li></ol><p>如果命名包括多个单词，通常采用驼峰式命名法，也就是，单词一个接一个，除了第一个单词，其他的每个单词都以大写字母开头：<code>myVeryLongName</code>。</p><div class="note info flat"><p>区分大小写，允许非英文字母</p></div><div class="note warning flat"><p>有一张<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#keywords">保留字列表</a>，表中的保留字无法作为变量名</p></div><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>声明一个常数变量，可以使用<code>const</code>而非<code>let</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myBirthday = <span class="string">&#x27;01.01.2001&#x27;</span></span><br></pre></td></tr></table></figure><p>使用<code>const</code>声明的变量称为“常量”。它们不能被修改，如果尝试修改就会报错</p><p>当能确定一个量不会改变是，就将其声明为常量，来传递这个信息</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>JavaScript中的值都有特定的类型，在JavaScript中有8种基本的数据类型。我们可以将任何类型的值存入变量，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">message = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>允许这种操作的编程语言，被称为<strong>动态类型</strong>的编程语言</p><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p><em>number</em>类型代表整数和浮点数。数字可以有很多种操作，比如，乘法 <code>*</code>、除法 <code>/</code>、加法 <code>+</code>、减法 <code>-</code> </p><p>除了常规的数字，还包括“特殊数值”（“special numeric values”）：<code>Infinity</code>，<code>-Infinity</code>，<code>NaN</code>。</p><ul><li><p><code>Infinity</code>代表数学中的无穷大$\infty$，可以通过除以$0$或直接使用来得到它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">1</span> / <span class="number">0</span>); <span class="comment">//Infinity</span></span><br><span class="line">alert(<span class="literal">Infinity</span>); <span class="comment">//Infinity</span></span><br></pre></td></tr></table></figure></li><li><p><code>NaN</code>代表一个计算错误。它是一个不正确或者未定义的一个数学操作所得到的结果，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&quot;not a number&quot;</span> / <span class="number">2</span>); <span class="comment">//这样的除法是错误的</span></span><br></pre></td></tr></table></figure><p><code>NaN</code>是粘性的。对任何<code>NaN</code>的进一步操作都会返回<code>NaN</code></p></li></ul><div class="note info flat"><p>在JavaScript中做数学运算是安全的，最坏情况会返回<code>NaN</code></p></div><h2 id="BigInt类型"><a href="#BigInt类型" class="headerlink" title="BigInt类型"></a>BigInt类型</h2><p>在JavaScript中，“number”类型无法表示大于<code>2^53 - 1</code>的整数，要表示超过这个范围的数字时，需要用到<em>BigInt</em>类型。<em>BigInt</em>可以表示任意长度的整数。可以通过将<code>n</code>附加到整数字段的末尾来创建<code>BigInt</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bigInt = <span class="number">1234567890123456789012345678901234567890n</span>;</span><br></pre></td></tr></table></figure><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>JavaScript中的字符串必须被括在引号里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;Single quotes&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> phrase = <span class="string">`can embed another <span class="subst">$&#123;str&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p>在JavaScript中，有三种包含字符串的方法</p><ol><li>双引号：<code>&quot;Hello&quot;</code></li><li>单引号：<code>&#39;Hello&#39;</code></li><li>反引号</li></ol><p>双引号和单引号都是“简单”引用,反引号是 <strong>功能扩展</strong> 引号。它们允许我们通过将变量和表达式包装在 <code>$&#123;…&#125;</code> 中，来将它们嵌入到字符串中。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌入一个变量</span></span><br><span class="line">alert( <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span> ); <span class="comment">// Hello, John!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌入一个表达式</span></span><br><span class="line">alert( <span class="string">`the result is <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span>&#125;</span>`</span> ); <span class="comment">// the result is 3</span></span><br></pre></td></tr></table></figure><p><code>$&#123;…&#125;</code> 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 <code>$&#123;…&#125;</code> 内放置任何东西：诸如名为 <code>name</code> 的变量，或者诸如 <code>1 + 2</code> 的算数表达式，或者其他一些更复杂的。</p><h2 id="Boolean类型（逻辑类型）"><a href="#Boolean类型（逻辑类型）" class="headerlink" title="Boolean类型（逻辑类型）"></a>Boolean类型（逻辑类型）</h2><p>boolean类型仅包含两个值：<code>true</code>和<code>false</code></p><h2 id="”null“值"><a href="#”null“值" class="headerlink" title="”null“值"></a>”null“值</h2><p>特殊的<code>null</code>值不属于上述任何一种类型，它构成了一个独立的类型，只包含<code>null</code>值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="”undefined“值"><a href="#”undefined“值" class="headerlink" title="”undefined“值"></a>”undefined“值</h2><p>特殊值<code>undefined</code>和<code>null</code>一样自成类型。<code>undefined</code>的含义是<strong>未被赋值</strong>，如果一个变量已经被定义，但是未被赋值，那么它的值就是<code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age;</span><br><span class="line">alert(age); <span class="comment">//弹出”undefined“</span></span><br></pre></td></tr></table></figure><h2 id="object类型和symbol类型"><a href="#object类型和symbol类型" class="headerlink" title="object类型和symbol类型"></a>object类型和symbol类型</h2><p><code>object</code>类型是一个特殊的类型，用于储存数据几何体和更复杂的实体。<code>symbol</code>类型用于创建对象的唯一标识符。</p><h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p><code>typeof</code> 运算符返回参数的类型。当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，非常有用。</p><p>它支持两种语法形式：</p><ol><li>作为运算符：<code>typeof x</code>。</li><li>函数形式：<code>typeof(x)</code>。</li></ol><p>换言之，有括号和没有括号，得到的结果是一样的。</p><p>对 <code>typeof x</code> 的调用会以字符串的形式返回数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">0</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">10n</span> <span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;foo&quot;</span> <span class="comment">// &quot;string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>) <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span> <span class="comment">// &quot;object&quot;  (1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;  (2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> alert <span class="comment">// &quot;function&quot;  (3)</span></span><br></pre></td></tr></table></figure><h1 id="交互：alert、prompt和confirm"><a href="#交互：alert、prompt和confirm" class="headerlink" title="交互：alert、prompt和confirm"></a>交互：alert、prompt和confirm</h1><h2 id="alert"><a href="#alert" class="headerlink" title="alert"></a>alert</h2><p>会显示一条信息，并等待用户按下”OK“。</p><p>弹出的这个带有信息的小窗口被称为 <strong>模态窗</strong>。“modal” 意味着用户不能与页面的其他部分（例如点击其他按钮等）进行交互，直到他们处理完窗口。在上面示例这种情况下 —— 直到用户点击“确定”按钮。</p><h2 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h2><p><code>prompt</code>函数接收两个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = prompt(title, [<span class="keyword">default</span>]);</span><br></pre></td></tr></table></figure><p>浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定/取消按钮。</p><ul><li><p><code>title</code></p><p>显示给用户的文本</p></li><li><p><code>default</code></p><p>可选的第二个参数，指定 input 框的初始值。</p></li></ul><p>访问者可以在提示输入栏中输入一些内容，然后按“确定”键。然后我们在 <code>result</code> 中获取该文本。或者他们可以按取消键或按 Esc 键取消输入，然后我们得到 <code>null</code> 作为 <code>result</code>。</p><p><code>prompt</code> 将返回用户在 <code>input</code> 框内输入的文本，如果用户取消了输入，则返回 <code>null</code>。</p><h2 id="confirm"><a href="#confirm" class="headerlink" title="confirm"></a>confirm</h2><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = confirm(question);</span><br></pre></td></tr></table></figure><p><code>confirm</code> 函数显示一个带有 <code>question</code> 以及确定和取消两个按钮的模态窗口。</p><p>点击确定返回 <code>true</code>，点击取消返回 <code>false</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Programming Languages </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch 01 —— Tensors</title>
      <link href="2021/01/10/Pytorch-01/"/>
      <url>2021/01/10/Pytorch-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Tensors-张量"><a href="#Tensors-张量" class="headerlink" title="Tensors(张量)"></a>Tensors(张量)</h1><p>Tensor是一种特殊的数据结构，它与array和matrix类似。在Pytorch中，我们用tensor来储存一个模型的输入和输出。Tensor与numpy中的ndarrays类似，但是tensor能使用GPU等硬件设备来加速计算。在使用之前要引入以下库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h1 id="Tensor初始化"><a href="#Tensor初始化" class="headerlink" title="Tensor初始化"></a>Tensor初始化</h1><p>tensor有多种初始化的方法：</p><h2 id="从基本数据类型出发"><a href="#从基本数据类型出发" class="headerlink" title="从基本数据类型出发"></a>从基本数据类型出发</h2><p>tensor可由基本数据类型初始化，tensor的数据类型可以自动推导</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">x_data = torch.tensor(data)</span><br></pre></td></tr></table></figure><h2 id="从Numpy-array出发"><a href="#从Numpy-array出发" class="headerlink" title="从Numpy array出发"></a>从Numpy array出发</h2><p>Tensor可以由Numpy array 类型初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np_array = np.array(data)</span><br><span class="line">x_np = torch.from_numpy(np_array)</span><br></pre></td></tr></table></figure><h2 id="从另一个Tensor出发"><a href="#从另一个Tensor出发" class="headerlink" title="从另一个Tensor出发"></a>从另一个Tensor出发</h2><p>Tensor可以由另一个tensor构建，它保持了原Tensor的性质（shape,dtype），除非提供新值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x_ones = torch.ones_like(x_data)</span><br><span class="line">print(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;x_ones&#125;</span> \n&quot;</span>)</span><br><span class="line">x_rand = torch.rand_like(x_data, dtype = torch.<span class="built_in">float</span>)</span><br><span class="line">print(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;x_rand&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ones Tensor: </span><br><span class="line"> tensor([[1, 1],</span><br><span class="line">        [1, 1]]) </span><br><span class="line"></span><br><span class="line">Random Tensor: </span><br><span class="line"> tensor([[0.4990, 0.6255],</span><br><span class="line">        [0.4148, 0.0162]]) </span><br></pre></td></tr></table></figure><h2 id="随机数或常数"><a href="#随机数或常数" class="headerlink" title="随机数或常数"></a>随机数或常数</h2><p>有几个用来构建Tensor的常用函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shape = (<span class="number">2</span>, <span class="number">3</span>)  <span class="comment">#shape是一个用来表示tensor各维数量的tuple</span></span><br><span class="line">rand_tensor = torch.rand(shape)</span><br><span class="line">ones_tensor = torch.ones(shape)</span><br><span class="line">zeros_tensor = torch.zeros(shape)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;Zeros Tensor: \n <span class="subst">&#123;zeros_tensor&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Random Tensor: </span><br><span class="line"> tensor([[0.2932, 0.9156, 0.9483],</span><br><span class="line">        [0.4570, 0.9828, 0.2313]]) </span><br><span class="line"></span><br><span class="line">Ones Tensor: </span><br><span class="line"> tensor([[1., 1., 1.],</span><br><span class="line">        [1., 1., 1.]]) </span><br><span class="line"></span><br><span class="line">Zeros Tensor: </span><br><span class="line"> tensor([[0., 0., 0.],</span><br><span class="line">        [0., 0., 0.]])</span><br></pre></td></tr></table></figure><h1 id="Tensor属性"><a href="#Tensor属性" class="headerlink" title="Tensor属性"></a>Tensor属性</h1><p>一个Tensor有多个属性，它们描述了tensor的shape, dtype和储存设备（CPU, GPU等）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor = torch.rand(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&quot;Shape of tensor: <span class="subst">&#123;tensor.shape&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;Datatype of tensor: <span class="subst">&#123;tensor.dtype&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;Device tensor is stored on: <span class="subst">&#123;tensor.device&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape of tensor: torch.Size([3, 4])</span><br><span class="line">Datatype of tensor: torch.float32</span><br><span class="line">Device tensor is stored on: cpu</span><br></pre></td></tr></table></figure><h1 id="Tensor操作"><a href="#Tensor操作" class="headerlink" title="Tensor操作"></a>Tensor操作</h1><p>Tensor可以执行多种命令，具体的命令列表<a href="https://pytorch.org/docs/stable/torch.html">见此网页</a>，下面列举一些常用的</p><h2 id="转移到GPU"><a href="#转移到GPU" class="headerlink" title="转移到GPU"></a>转移到GPU</h2><p>如果有GPU和cuda，可以将tensor转移到GPU上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">  tensot = tensor.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h2><p>Tensor具有和numpy类似的索引和切片方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tensor = torch.ones(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">tensor[:, <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">print(tensor)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br></pre></td></tr></table></figure><h2 id="Tensor合并"><a href="#Tensor合并" class="headerlink" title="Tensor合并"></a>Tensor合并</h2><p>可以使用<code>torch.cat</code>函数来合并几个tensor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 = t1 = torch.cat([tensor, tensor, tensor], dim = <span class="number">1</span>)</span><br><span class="line">print(t1)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.]])</span><br></pre></td></tr></table></figure><h2 id="Tensor乘法"><a href="#Tensor乘法" class="headerlink" title="Tensor乘法"></a>Tensor乘法</h2><p>Tensor的乘法主要有两种，一种是Tensor中<strong>各元素直接相乘</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This computes the element-wise product</span></span><br><span class="line">print(<span class="string">f&quot;tensor.mul(tensor) \n <span class="subst">&#123;tensor.mul(tensor)&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="comment"># Alternative syntax:</span></span><br><span class="line">print(<span class="string">f&quot;tensor * tensor \n <span class="subst">&#123;tensor * tensor&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tensor.mul(tensor) </span><br><span class="line"> tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]]) </span><br><span class="line"></span><br><span class="line">tensor * tensor </span><br><span class="line"> tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br></pre></td></tr></table></figure><p>另一种是Tensor的<strong>矩阵相乘</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">f&quot;tensor.matmul(tensor.T) \n <span class="subst">&#123;tensor.matmul(tensor.T)&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="comment"># Alternative syntax:</span></span><br><span class="line">print(<span class="string">f&quot;tensor @ tensor.T \n <span class="subst">&#123;tensor @ tensor.T&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tensor.matmul(tensor.T) </span><br><span class="line"> tensor([[3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.]]) </span><br><span class="line"></span><br><span class="line">tensor @ tensor.T </span><br><span class="line"> tensor([[3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.]])</span><br></pre></td></tr></table></figure><h2 id="原地操作"><a href="#原地操作" class="headerlink" title="原地操作"></a>原地操作</h2><p>带有<code>_</code>后缀的操作是原地操作。比如<code>x = copy_(y)</code>，<code>x = t_()</code>会改变x的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(tensor, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">tensor.add_(<span class="number">2</span>)</span><br><span class="line">print(tensor)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]]) </span><br><span class="line"></span><br><span class="line">tensor([[3., 2., 3., 3.],</span><br><span class="line">        [3., 2., 3., 3.],</span><br><span class="line">        [3., 2., 3., 3.],</span><br><span class="line">        [3., 2., 3., 3.]])</span><br></pre></td></tr></table></figure><h1 id="Numpy-和-Tensor-的联系"><a href="#Numpy-和-Tensor-的联系" class="headerlink" title="Numpy 和 Tensor 的联系"></a>Numpy 和 Tensor 的联系</h1><p>在CPU上的Tensor和Numpy array共享一块内存空间，因此改变一个会带来另一个的改变</p><h2 id="Tensor到Numpy-array"><a href="#Tensor到Numpy-array" class="headerlink" title="Tensor到Numpy array"></a>Tensor到Numpy array</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = torch.ones(<span class="number">5</span>)</span><br><span class="line">print(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line">n = t.numpy()</span><br><span class="line">print(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t: tensor([1., 1., 1., 1., 1.])</span><br><span class="line">n: [1. 1. 1. 1. 1.]</span><br></pre></td></tr></table></figure><h2 id="Numpy-array到Tensor"><a href="#Numpy-array到Tensor" class="headerlink" title="Numpy array到Tensor"></a>Numpy array到Tensor</h2><p>调用<code>from_numpy</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = np.ones(<span class="number">5</span>)</span><br><span class="line">t = torch.from_numpy(n)</span><br></pre></td></tr></table></figure><h2 id="两者的关联"><a href="#两者的关联" class="headerlink" title="两者的关联"></a>两者的关联</h2><p>改变Tensor或Numpy array中的任一个都会使得另一个发生改变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.add(n, <span class="number">1</span>, out=n)</span><br><span class="line">print(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br><span class="line">t.add_(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t: tensor([2., 2., 2., 2., 2.])</span><br><span class="line">n: [2. 2. 2. 2. 2.]</span><br><span class="line">t: tensor([3., 3., 3., 3., 3.])</span><br><span class="line">n: [3. 3. 3. 3. 3.]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming Languages </category>
          
          <category> Python </category>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Python </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Statistical Learning Method 01</title>
      <link href="2020/12/27/statistical-learning-method-1/"/>
      <url>2020/12/27/statistical-learning-method-1/</url>
      
        <content type="html"><![CDATA[<h1 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h1><p>统计学习(Statistical Learning)是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。统计学习也称为统计机器学习(Statistical Machine Learning)。</p><h1 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h1><h2 id="监督学习-Supervised-Learning"><a href="#监督学习-Supervised-Learning" class="headerlink" title="监督学习(Supervised Learning)"></a>监督学习(Supervised Learning)</h2><h3 id="输入空间、特征空间与输出空间"><a href="#输入空间、特征空间与输出空间" class="headerlink" title="输入空间、特征空间与输出空间"></a>输入空间、特征空间与输出空间</h3><p>在监督学习中，将输入与输出所有可能性的集合分别称为<strong>输入空间(Input Space) 与输出空间(Output Space)</strong>。输入与输出空间可以是有限元素的集合，也可以是整个欧氏空间。</p><p>每个具体的输入时一个<strong>实例(Instance)</strong>，通常由<strong>特征向量(Feature Vector)</strong>表示。所有特征向量存在的空间称为<strong>特种空间(Feature Space)</strong>。特征空间的每一维对应一个特征。</p><p>在监督学习中，将输入与输出看做是定义在输入（特征）空间上的与输出空间上的随机变量的取值。输入输出变量用大写字母表示，变量的取值用小写字母表示。输入实例$x$的特征向量记作</p><script type="math/tex; mode=display">x = \left( x^{(1)}, x^{(2)}, \ldots , x^{(i)}, \ldots, x^{(n)} \right)^T</script><p>监督学习从训练数据（training data）集合中学习模型，对测试数据（test data）进行预测。训练数据由输入（或特征向量）与输出对组成，训练集通常表示为</p><script type="math/tex; mode=display">T=\left\{ (x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n) \right\}</script><p>测试数据也由输入与输出对组成。输入与输出对又称为样本（sample）或样本点</p><p>输入变量$X$和输出变量$Y$有不同的类型，可以是连续的，也可以使离散的。根据输入输出变量的不同类型，对预测人物给予不同的名称：输入变量与输出变量均为连续变量的预测问题称为<strong>回归问题</strong>，输出变量为有限个离散变量的预测问题为<strong>分类问题</strong>；输入变量和输出变量均为变量序列的预测问题为<strong>标注问题</strong></p><h3 id="联合概率分布"><a href="#联合概率分布" class="headerlink" title="联合概率分布"></a>联合概率分布</h3><p>监督学习假设输入和输出的随机变量$X$和$Y$遵循联合概率分布$P(X,Y)$。在学习的过程中，假定这一联合概率分布存在，但对学习系统来说，联合概率分布的具体定义是未知的。训练数据和册数数据被看做是依照联合概率分布$P(X,Y)$独立同分布产生的</p><h3 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h3><p>监督学习的目的在于学习一个由输入到输出的映射。这个映射由模型来表示，学习的摸底是找到最好的模型。模型属于由输入空间到输出空间的映射的集合，这个集合就是<strong>假设空间（hypothesis space）</strong>。假设空间的确定意味着学习范围的确定。</p><p>监督学习的模型可以是概率模型或非概率模型。由条件概率分布$P(Y|X)$或决策函数（decision function）$Y=f(X)$表示</p><h3 id="问题的形式化"><a href="#问题的形式化" class="headerlink" title="问题的形式化"></a>问题的形式化</h3><p>减速学习利用训练数据集学习一个模型，再用模型对测试样本集进行预测。监督学习分为<strong>学习</strong>和<strong>预测</strong>两个构成，由<strong>学习系统和预测系统</strong>完成</p><div class="mermaid">graph LRA[学习系统] --&gt;B[(模型)]  B --&gt; C[预测系统]  C --&gt; B D[测试样本X] --&gt; C  C --&gt; E[测试样本Y]</div><p>首先给定一个训练数据集</p><script type="math/tex; mode=display">T=T=\left\{ (x_1, y_1), (x_2, y_2), \ldots, (x_N, y_N) \right\}</script><p>其中$(x_i, y_i),i=1,2,\ldots,n$称为样本或样本点。$x_i\in \mathcal{X}\subseteq \mathbb{R}^n$是输入的观测值，也称为输入或实例，$y_i\in\mathcal{Y}$是输出的观测值，也称为输出</p><h2 id="无监督学习-Unsupervised-Learning"><a href="#无监督学习-Unsupervised-Learning" class="headerlink" title="无监督学习(Unsupervised Learning)"></a>无监督学习(Unsupervised Learning)</h2><p>无监督学习是指从无标注的数据中学习预测模型的机器学习问题。无标注数据是自然得到的数据，预测模型表示数据的类别、转换或概率。无监督学习的本质是学习数据中的统计规律或潜在结构</p><h2 id="强化学习-Reinforcement-Learning"><a href="#强化学习-Reinforcement-Learning" class="headerlink" title="强化学习(Reinforcement Learning)"></a>强化学习(Reinforcement Learning)</h2><p>强化学习是指智能系统在与环境的连续互动中学习最优行为策略的机器学习问题</p><h1 id="统计学习方法三要素"><a href="#统计学习方法三要素" class="headerlink" title="统计学习方法三要素"></a>统计学习方法三要素</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>统计学习首要考虑的问题是学习什么样的模型。在监督学习过程中，模型就是<em>所要学习的条件概率分布或决策函数</em>。模型的<strong>假设空间</strong>包含所有可能的条件概率分布或决策函数。</p><p>假设空间用$\mathcal{F}$表示，假设空间可以定义为决策函数的集合：</p><script type="math/tex; mode=display">\mathcal{F} = \left\{f|Y=f(X) \right\}</script><p>或者条件概率的集合</p><script type="math/tex; mode=display">\mathcal{F} = \left\{P|P(Y|X)\right\}</script>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Machine Learning </category>
          
          <category> Statistical Learning Method </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Artificial Intellegence </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
